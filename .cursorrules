# ERP 프로젝트 개발 규칙

# 프로젝트 개요
백엔드: Java Spring Boot 3 + WAR 배포
프론트엔드: Vite + React + TypeScript
GitLab(개발) + GitHub(포트폴리오) 멀티 리모트 관리
파일 경로와 확장자로 백엔드/프론트엔드 컨텍스트 자동 구분

# 프로젝트 구조
```
project-root/
├── backend/
│   ├── src/main/java/
│   │   ├── controller/
│   │   ├── service/
│   │   ├── repository/
│   │   ├── entity/
│   │   ├── dto/
│   │   └── exception/
│   ├── src/main/resources/
│   │   ├── application.yml         # 공개 가능한 기본 설정
│   │   ├── application-dev.yml.example  # 개발 환경 템플릿 (GitHub)
│   │   ├── application-dev.yml     # 실제 개발 설정 (GitLab만)
│   │   └── application-prod.yml    # 실제 운영 설정 (GitLab만)
└── frontend/
    ├── src/
    │   ├── components/
    │   ├── pages/
    │   ├── hooks/
    │   ├── services/
    │   ├── types/
    │   ├── utils/
    │   └── assets/
    ├── public/
    └── dist/
```

# 백엔드 - Java Spring Boot

## AI 역할
- 시니어 Java 개발자 역할
- SOLID, DRY, KISS, YAGNI 원칙 준수
- OWASP 보안 가이드라인 준수
- 문제를 단계별로 분해하여 접근

## 기술 스택
- Spring Boot 3, Java 17, Maven
- 패키징: WAR (외부 톰캣 배포)
- 의존성: Spring Web, Spring Data JPA, Lombok, PostgreSQL Driver
- spring-boot-starter-tomcat은 scope=provided

## WAR 배포 설정
```xml
<packaging>war</packaging>
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-tomcat</artifactId>
  <scope>provided</scope>
</dependency>
```

SpringBootServletInitializer 상속 필수:
```java
@SpringBootApplication
public class ErpApplication extends SpringBootServletInitializer {
  @Override
  protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
    return builder.sources(ErpApplication.class);
  }
}
```

## 아키텍처 설계 원칙
- 모든 요청/응답은 @RestController에서만 처리
- DB 접근은 반드시 ServiceImpl → Repository 경로 사용
- Controller는 Repository 직접 호출 금지 (예외적 상황만 허용)
- Controller ↔ Service 간 데이터 전달은 DTO만 사용
- Entity는 DB 입출력 전용

## 엔티티 (Entity)
- @Entity 어노테이션 필수
- 기본적으로 Lombok @Data 사용
- PK: @Id + @GeneratedValue(strategy = GenerationType.IDENTITY)
- 연관관계는 기본 FetchType.LAZY
- @NotBlank, @Email, @Size 등 Bean Validation 적극 활용

## 레포지토리 (Repository)
- @Repository + interface 구조
- JpaRepository<Entity, ID> 상속
- @Query 사용 시 JPQL 우선
- N+1 방지: @EntityGraph(attributePaths={"연관엔티티"}) 활용
- 다중 Join 결과는 DTO 프로젝션으로 반환

## 서비스 (Service)
- Service는 interface, 구현은 ServiceImpl
- @Service 어노테이션 필수
- 의존성 주입: 필드 @Autowired 방식 (명시적 요청 시 제외)
- 반환 타입은 DTO 권장 (Entity 반환은 최소화)
- 존재 여부 확인: repository.findById(id).orElseThrow() 패턴
- 다중 DB 작업: @Transactional 또는 transactionTemplate 필수

## DTO (Data Transfer Object)
- Java 17 record 타입 기본 사용
- compact canonical constructor에서 입력값 검증 (null, blank, 길이 제한)

## RestController
- 클래스 단위: @RestController
- API Prefix: @RequestMapping("/api/리소스명")
- HTTP 메서드: @GetMapping, @PostMapping, @PutMapping, @DeleteMapping
- 리소스 기반 URL (/users/{id}), 동사형 URL 금지 (/create, /update)
- 반환 타입: ResponseEntity<ApiResponse>
- 메서드 로직: try..catch 블록 필수
- 에러 처리: 전역 GlobalExceptionHandler 활용

# 프론트엔드 - Vite + React + TypeScript

## AI 역할
- TypeScript, React, Vite 전문가
- 함수형/선언형 프로그래밍 지향
- 모듈화 우선, 불필요한 상태 최소화

## 기술 스택
- Vite (번들러)
- React 18 + TypeScript
- React Query (TanStack Query) + Axios
- TailwindCSS + Shadcn UI + Radix UI
- Zod 폼 검증
- React Router DOM (SPA 라우팅)

## 코딩 원칙
- 디렉토리명: 소문자-대시 (components/auth-form)
- Named Export 권장
- RORO(Receive Object, Return Object) 패턴
- 가드절(early return) 적극 활용
- 예상 가능한 오류는 return value로 처리, try/catch는 예외 상황만
- 사용자 친화적 에러 메시지 (한국어)

## 구현 규칙
- 함수형 컴포넌트만 사용 (function 키워드)
- React hooks 적극 활용 (useState, useEffect, useMemo, useCallback)
- 컴포넌트 재사용성 고려한 props 설계
- 이미지: WebP + Lazy Loading
- API 응답 타입은 백엔드 DTO와 동일한 인터페이스 정의

## Vite 설정 패턴
```typescript
// vite.config.ts
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@components': path.resolve(__dirname, './src/components'),
      '@pages': path.resolve(__dirname, './src/pages'),
      '@utils': path.resolve(__dirname, './src/utils'),
      '@types': path.resolve(__dirname, './src/types'),
      '@services': path.resolve(__dirname, './src/services'),
    },
  },
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true,
      },
    },
  },
})
```

## 프론트엔드 환경 설정
```typescript
// src/config/env.ts
export const env = {
  API_BASE_URL: import.meta.env.VITE_API_BASE_URL || 'http://localhost:8080/api',
  NODE_ENV: import.meta.env.MODE,
  IS_DEV: import.meta.env.MODE === 'development',
} as const

// Vite 환경변수 파일 (.env.development, .env.production)
VITE_API_BASE_URL=http://localhost:8080/api
VITE_ENABLE_DEV_TOOLS=true
```

# 공통 규칙

## API 통신
- 백엔드: RESTful + 표준 ApiResponse
- 프론트엔드: React Query + Axios 인터셉터
- DTO ↔ TS 인터페이스 네이밍 일관
- 개발/운영 CORS 적절 설정

## 에러 처리
- 백엔드: GlobalExceptionHandler → ApiResponse(한국어 메시지)
- 프론트엔드: React Query의 에러 바운더리 + 사용자 메시지 상수
- 내부 스택/원인: 로그로만 남기고 사용자에겐 요약 메시지 제공

# 민감정보 보호 규칙

## 코드 작성 원칙
- 하드코딩 절대 금지: IP, 도메인, 비밀번호, API 키
- YML 파일에 모든 설정 관리
- 주석에도 민감정보 포함 금지
- 로그에 민감정보 출력 금지

## 파일 분류 원칙
### GitLab 전용 (민감정보 포함)
- application-dev.yml, application-prod.yml
- 실제 서버 정보가 포함된 설정 파일들

### GitHub 공개 (포트폴리오용)
- application.yml (기본 공개 설정)
- application-dev.yml.example (개발 환경 템플릿)
- 소스 코드 (민감정보 제거된 버전)
- README.md (포트폴리오용)

## Spring Boot 설정 패턴
```yaml
# application.yml (공개 가능 - 기본 설정)
spring:
  application:
    name: erp-system
  profiles:
    active: dev
  datasource:
    url: jdbc:postgresql://localhost:5432/erp_db
    username: dev_user
    password: dev_password
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: false

server:
  port: 8080
  servlet:
    context-path: /api

# JWT 기본 설정
jwt:
  secret: default-jwt-secret-for-development
  expiration: 3600000
```

```yaml
# application-dev.yml.example (GitHub 템플릿)
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/erp_database
    username: your_username
    password: your_password
  jpa:
    show-sql: true
    hibernate:
      ddl-auto: update

# JWT 설정
jwt:
  secret: your-jwt-secret-key
  expiration: 86400000

# 외부 API 설정
external:
  api:
    url: https://api.example.com
    key: your-api-key

# 서버 설정
server:
  host: your-server-host
  port: 8080
```

```yaml
# application-dev.yml (GitLab 실제 개발 설정)
spring:
  datasource:
    url: jdbc:postgresql://192.168.1.100:5432/erp_dev
    username: real_dev_user
    password: real_dev_password_123
  jpa:
    show-sql: true
    hibernate:
      ddl-auto: update

# JWT 실제 설정
jwt:
  secret: real-development-jwt-secret-key-abcd1234
  expiration: 86400000

# 외부 API 실제 설정
external:
  api:
    url: https://dev-api.company.com
    key: sk-real-dev-api-key-xyz789

# 실제 서버 설정
server:
  host: 192.168.1.100
  port: 8080
```

## Java 코드에서 YML 값 사용 패턴
```java
// ✅ 올바른 예: @Value로 YML 값 주입
@Value("${spring.datasource.url}")
private String databaseUrl;

@Value("${jwt.secret}")
private String jwtSecret;

@Value("${external.api.url}")
private String externalApiUrl;

@Value("${server.host}")
private String serverHost;

// ✅ @ConfigurationProperties 사용 (권장)
@ConfigurationProperties(prefix = "jwt")
@Data
public class JwtProperties {
    private String secret;
    private long expiration;
}

@ConfigurationProperties(prefix = "external.api")
@Data
public class ExternalApiProperties {
    private String url;
    private String key;
}
```

```java
// ❌ 잘못된 예: 하드코딩
private String jwtSecret = "my-real-secret-key-123";
private String databaseUrl = "jdbc:postgresql://192.168.1.100:5432/erp_prod";
private String apiKey = "sk-real-api-key-abcd1234";
```

# 보안 규칙

## 백엔드 보안
- Spring Security 기본 활성화 (개발/운영 동일)
- HTTP 보안 헤더: HSTS, X-Content-Type-Options, X-Frame-Options, CSP
- 입력 검증: DTO + Bean Validation + ControllerAdvice
- 의존성 보안 스캔: OWASP Dependency-Check

## 개발 환경 보안 원칙
- 인증/인가 로직은 절대 비활성화하지 않음
- 개발 편의를 위해 테스트 계정 자동 생성
  - 관리자: admin / admin123
  - 사용자: user / user123
- 빠른 로그인 기능은 개발 환경에서만 활성화
- JWT 만료 시간만 개발 환경에서 연장 (24시간)

## 개발 환경 설정 예시
```yaml
# application-dev.yml (실제 개발용 - GitLab 전용)
spring:
  profiles:
    active: dev
  datasource:
    url: jdbc:postgresql://192.168.1.100:5432/erp_dev
    username: dev_user
    password: secure_dev_password_123
  jpa:
    show-sql: true
    hibernate:
      ddl-auto: update

# JWT 개발 설정 (만료시간 길게)
jwt:
  secret: development-jwt-secret-key-for-local-only
  expiration: 86400000  # 24시간

# 개발용 테스트 계정 활성화
app:
  dev-accounts:
    enabled: true
    admin:
      username: admin
      password: admin123
    user:
      username: user
      password: user123

logging:
  level:
    com.example.erp: DEBUG
    org.springframework.security: DEBUG
```

## 프론트엔드 보안
- 개발 환경에서도 인증 유지 (테스트 계정 사용)
- CSP 적용, dangerouslySetInnerHTML 금지
- 토큰: HTTPOnly/Secure/SameSite 쿠키 권장
- 에러 상세는 로깅만, 사용자에겐 요약 메시지

```typescript
// 개발 환경 전용 컴포넌트 패턴
export function DevQuickLogin() {
  // 운영 환경에서는 렌더링하지 않음
  if (import.meta.env.MODE !== 'development') {
    return null
  }
  
  return (
    <div className="dev-quick-login">
      {/* 개발용 빠른 로그인 UI */}
    </div>
  )
}
```

# 다국어 (i18n)

## 백엔드
- messages.properties (기본), messages_ko.properties, messages_en.properties
- AcceptHeaderLocaleResolver, 기본 로케일: ko-KR
- Bean Validation 메시지는 메시지 코드로 연결

## 프론트엔드
- React i18next 사용
- 키 네이밍: domain.page.action.message
- Zod 에러 한글화
- 모든 사용자 노출 텍스트는 i18n 키 사용

```typescript
// Zod 한글화 패턴
z.setErrorMap((issue, ctx) => {
  switch (issue.code) {
    case 'invalid_type':
      return { message: '형식이 올바르지 않습니다' }
    case 'too_small':
      return { message: `최소 ${issue.minimum}자 이상 입력해주세요` }
    default:
      return { message: ctx.defaultError }
  }
})
```

# 코드 스타일

## 백엔드 (Java)
- Google Java Style Guide 준수
- Spotless + Checkstyle + SpotBugs 적용
- @SuppressWarnings 사용 시 사유 주석 필수

## 프론트엔드 (TypeScript)
- ESLint + Prettier 통합
- 절대경로 import 및 정렬 (Vite alias 활용)
- 컴포넌트 파일 당 1개 export 권장

# 테스트 전략

## 백엔드
- 단위: JUnit 5 + Mockito
- 통합: Testcontainers (PostgreSQL) + @SpringBootTest
- 커버리지: JaCoCo 80% 이상

## 프론트엔드
- 단위/컴포넌트: Vitest + React Testing Library
- E2E: Playwright
- 커버리지: 80% 목표

# 로그 & 관찰성

## 백엔드
- Logback JSON 로깅 + MDC (Correlation ID)
- 레벨: Controller/Service/Repository = INFO, 외부연동 = DEBUG
- 감사 로그: 별도 AUDIT 로거 사용

## 프론트엔드
- 콘솔 에러는 사용자에게 노출하지 않음
- 환경변수로 APM 연동 제어

# 코드 주석 규칙

## Java
```java
/**
 * ERP 시스템의 주문 관리 서비스
 * 주문 생성, 수정, 취소 등의 비즈니스 로직을 처리합니다
 */
@Service
public class OrderServiceImpl implements OrderService {
  /**
   * 새로운 주문을 생성합니다
   * @param orderDto 주문 정보
   * @return 생성된 주문 정보
   * @throws IllegalArgumentException 주문 정보가 유효하지 않은 경우
   */
  @Transactional
  public OrderDto createOrder(OrderCreateDto orderDto) {
    // 비즈니스 로직 구현
  }
}
```

## TypeScript
```typescript
/**
 * 주문 관리 페이지 (Vite + React)
 * 주문 목록 조회, 검색, 필터링 기능을 제공합니다
 */
function OrderManagement() {
  const { t } = useTranslation()
  
  // 비즈니스 로직 구현
  
  return (
    <div className="order-management">
      {/* 컴포넌트 구현 */}
    </div>
  )
}

export { OrderManagement }
```